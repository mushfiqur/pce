#include "../include/BasisPolys.h"

BasisPolySet::BasisPolySet(int num_vars, int order){
	var* x_i;

	for(int i = 0; i < num_vars; i++){
		x_i = new var(1, -1, i+1);
		this->var_arr.push_back(x_i);
	}

	///////////////////////////////////////////////////
	std::vector<std::vector<polynomial*>> univariate_polys(num_vars);

	polynomial* p;
	for(int i = 0; i < num_vars; i++){
		univariate_polys[i] = std::vector<polynomial*>();

		p = new polynomial();
		p->m->coeff = 1.0;
		p->max_exp = 0;
		p->prev = nullptr;
		p->next = nullptr;

		univariate_polys[i].push_back(p);

		p = new polynomial();
		p->m->coeff = 1.0;
		p->m->arr.push_back(new term{.v = this->var_arr[i], .exp = 1});
		p->max_exp = 1;
		p->next = nullptr;
		p->prev = nullptr;

		univariate_polys[i].push_back(p);

		p = new polynomial();
		p->m->coeff = 1.5;
		p->m->arr.push_back(new term{.v = this->var_arr[i], .exp = 2});
		p->next = new polynomial();
		p->next->m->coeff = -0.5;
		p->next->prev = p;
		p->max_exp = 2;
		
		univariate_polys[i].push_back(p);
/*
		p = new polynomial();
		p->m->coeff = 2.5;
		p->m->arr.push_back(new term{.v = this->var_arr[i], .exp = 3});
		p->next = new polynomial();
		p->next->m->coeff = -1.5;
		p->next->m->arr.push_back(new term{.v = this->var_arr[i], .exp = 1});
		p->next->prev = p;
		p->max_exp = 2;
		
		univariate_polys[i].push_back(p);
*/
	}

	///////////////////////////////////////////////////
	faster_tensor_prod(univariate_polys, this->basis_polys, order);
	this->set_size = this->basis_polys.size();

	// TODO: Fix this very bad hack to keep accomodate else block within faster_tensor_prod
	if(univariate_polys.size() > 1){
		for(int i = 0; i < univariate_polys.size(); i++){
			for(int j = 0; j < univariate_polys[i].size(); j++){
				delete univariate_polys[i][j];
			}
		}
	}
	///////////////////////////////////////////////////
	
	std::cout << "Basis set has: " << this->set_size << " polynomials" << std::endl;

	BasisPolySet::gen_exp_table();
	BasisPolySet::gen_exp_sqr_table();
}

BasisPolySet::~BasisPolySet(){
	for(int i = 0; i < var_arr.size(); i++){
		delete var_arr[i];
	}
	for(int i = 0; i < basis_polys.size(); i++){
		delete basis_polys[i];
	}
}

void BasisPolySet::gen_exp_table(){
	polynomial* p1;
	polynomial* p2;
	double exp_val = 0.0;

	int n = basis_polys.size();
	this->exp_table = std::vector<std::vector<std::vector<double>>>(n, std::vector<std::vector<double>>(n, std::vector<double>(n, 0.0)));

	for(int i = 0; i < this->set_size; i++){
		for(int j = i; j < this->set_size; j++){
			for(int k = j; k < this->set_size; k++){
				p1 = new polynomial();
				p2 = new polynomial();

				mult_poly(basis_polys[i], basis_polys[j], p1);
				mult_poly(p1, basis_polys[k], p2);
				
				exp_val = expect_poly(p2);

				this->exp_table[i][j][k] = exp_val;
				this->exp_table[i][k][j] = exp_val;
				this->exp_table[j][i][k] = exp_val;
				this->exp_table[j][k][i] = exp_val;
				this->exp_table[k][i][j] = exp_val;
				this->exp_table[k][j][i] = exp_val;
				
				delete p1;
				delete p2;
			}
		}
	}
}

void BasisPolySet::gen_exp_sqr_table(){
	polynomial* p;
	this->exp_sqr_table = std::vector<double>(basis_polys.size(), 0.0);

	for(int i = 0; i < this->set_size; i++){
		p = new polynomial();
		mult_poly(this->basis_polys[i], this->basis_polys[i], p);
		this->exp_sqr_table[i] = expect_poly(p);
		delete p;		
	}
}

int BasisPolySet::get_var_idx(int id){
	for(int i = 0; i < this->basis_polys.size(); i++){
		if(this->basis_polys[i]->max_exp == 1){
			if(this->basis_polys[i]->m->arr[0]->v->id == id){
				return i;
			}
		}
	}

	return -1;
}

void BasisPolySet::print(){
	polynomial* p;

	for(int i = 0; i < this->set_size; i++)	{
		std::cout << "P" << i << ": ";
		this->basis_polys[i]->print();
		std::cout << std::endl;

		std::cout << "E[P" << i << "]: ";
		std::cout << expect_poly(this->basis_polys[i]);
		std::cout << std::endl;

		std::cout << "E[(P" << i << ")^2]: ";
		std::cout << exp_sqr_table[i] << std::endl;
		
		std::cout << std::endl;
	}
}

void BasisPolySet::print_exp_table(){
	for(int i = 0; i < this->exp_table.size(); i++){
		for(int j = i; j < this->exp_table[i].size(); j++){
			for(int k = j; k < this->exp_table[j].size(); k++){
				std::cout << i << " " << j << " " << k << ": " << this->exp_table[i][j][k] << std::endl;
			}
		}
	}
}

void BasisPolySet::print_polys(){
	for(int i = 0; i < this->basis_polys.size(); i++){
		std::cout << "P" << i << ": ";
		this->basis_polys[i]->print();
		std::cout << std::endl;
	}
}